
# 1. 系统侧

* Android应用沙盒
* SELinux
* Android签名验证

# 2. 应用侧

## 2.1. Root环境检测

* 检查su文件是否存在：/system/bin/su
* 检查root进程：magiskd

## 2.2. 模拟器检测

## 2.3. 环境检测

* Magisk
* Frida

### 2.3.1. Frida检测

|检测方法|备注|过保护方法|
|---|---|---|
|文件检测|||
|端口检测|||
|双进程保护||spawn过保护|
|检测内存映射块|||
|检测status（线程名称）|||
|检测inline hook|||
|SVC指令|参考https://www.52pojie.cn/thread-1938862-1-1.html中的系统架构说明|搜索SVC汇编码进行Hook|

* 其他检测方式层出不穷，检测位置不定，还可能配合混淆手段加大分析难度，需具体情况具体分析，参考：https://www.52pojie.cn/thread-1938862-1-1.html。

#### 2.3.1.1. 对抗

* 魔改Frida：https://github.com/hzzheyang/strongR-frida-android

### 2.3.2. 抓包检测与对抗

* 抓包软件检测
* SSL + 代理软件检测
* 端口检测
* SSL + 证书校验

## 2.4. 代码混淆

* ProGuard
* R8
* DexGuard
  
## 2.5. 代码加固

### 2.5.1. 实现
* 360加固
* 腾讯加固
* 爱加密

### 2.5.2. 技术
* DEX加密与动态加载
* 加壳
* 反调试、反Hook
* JNI加密

## 2.6. 对抗
* apkid：识别壳
* Frida DumpDex：动态Dump Dex
* DexClassLoader：动态Dump Dex
* IDA手动Dump

## 2.7. 动态加载技术

通过DexClassLoader动态加载。

## 2.8. 数据加密

## 2.9. 校验

### 2.9.1. 签名校验

android.content.pm.PackageManager.getPackageInfo为获取签名信息的关键函数。

#### 2.9.1.1. 对抗方法

* 核心破解插件：直接安装不签名应用
* Lucky Patcher、MT、NP、ARMPro、CNFIX、Modex等一键去除签名校验工具
* 具体分析签名校验逻辑
* IO重定向：参考https://bbs.pediy.com/thread-273160.htm，通过VA进行SVC级别Hook，可使用平头哥框架进行操作
* Hook PackageManagerService（简称PMS，是Android系统核心服务之一，处理包管理相关的工作，常见的比如安装、卸载应用等）

## 2.10. 反调试

| **方法** | **原理** | **绕过方法** |
|---------|--------|------------|
| **`ptrace()`** | 防止进程被调试 | Hook `ptrace()`，返回 `0` |
| **`TracerPid` 监测** | 读取 `/proc/self/status` 判断是否被调试 | Hook `read()` 修改返回值 |
| **`getppid()` 监测** | 检测父进程是否为调试器 | Hook `getppid()`，返回 `0` |
| **`isDebuggerConnected()`** | 调用 `Debug.isDebuggerConnected()` 检测调试状态 | Hook 方法，返回 `false` |
| **`syscall` 监控** | 监视系统调用 | Hook `syscall`，修改 `ptrace` 调用 |
| **`anti-Frida` 检测** | 扫描 Frida 进程 & 端口 | 隐藏 Frida 进程，Hook `open()` |
| **`调试端口` 检测** | 扫描 调试器 进程 & 端口 | 隐藏进程，Hook `open()` |

## 2.11. HTTPS证书校验

Hook SSLPinning


# 3. 退出方式

kill/killProcess-----kill/KillProcess()可以杀死当前应用活动的进程，这一操作将会把所有该进程内的资源（包括线程全部清理掉）.当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因.

system.exit-----杀死了整个进程，这时候活动所占的资源也会被释放。

finish----------仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存，活动的资源并没有被清理

# 4. so防护手段

* SO加壳：对C/C++源码编译出来的SO文件进行加壳，使SO文件无法正确反编译和反汇编。
* SO源码虚拟化保护：将原始汇编指令翻译为自定义的虚拟机指令，跳转到自定义的虚拟机中执行，每次保护生成的虚拟机指令随机，且对虚拟机解释器再度混淆
* SO防调用：对SO文件进行授权绑定，防止SO文件被非授权应用调用运行。
* SO Linker：对整个SO文件进行加密压缩，包括代码段、符号表和字符串等，运行时再解密解压缩到内存，从而有效的防止SO数据的泄露。
* SO源码混淆：常量字符串加密、分裂基本块、等价指令替换、虚假控制流、控制流平坦化。
* SO环境监测：防frida\xposed\root、防动态调试、防模拟器、防多开等

# 5. 防护框架

## 5.1. ollvm

### 5.1.1. 基本原理

* 指令替换：将一条运算指令替换为多条等价的运算指令
* 虚假控制流：加入包含不透明谓词的条件跳转和不可达的基本块
* 控制流平坦化：通过一个主分发器来控制程序基本块的执行流程，将所有基本代码放到控制流最底部，然后删除原理基本块之间跳转关系，添加次分发器来控制分发逻辑，然后过新的复杂分发逻辑还原原来程序块之间的逻辑关系
* 字符串加密：常见特征-datadiv_decoded

### 5.1.2. 对抗

* angr去除不透明谓词
* Unicorn/Unidbg/AndroidNativeEmu模拟执行
* IDA Trace
* binary ninja
* 后端编译优化
