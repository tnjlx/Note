# 1. 变量和类型
* 流：字符连续生成或消耗
* 字面值类型前后缀
  * 前缀：u8、u、U、L
  * 后缀：U、F、L、LL
* 变量初始化方式：等于号（拷贝初始化）、括号及花括号（直接初始化）
* 变量声明语法：类型 + 声明符（包含标识符，引用的&和指针的*属于声明符的一部分）
* 引用即别名：左值引用和右值引用
* 空指针使用nullptr代替0
* const（顶层、底层）和constexpr
* typedef、auto、decltype
* 迭代器与泛型

# 2. 数组
* 流、数组不允许拷贝和赋值
  * 流和数组在作为函数参数传递时，需要使用引用形式
  * 数组在作为函数非引用参数时，实际传递的是数组指针
* begin和end有函数版本，可以用于数组

# 3. 运算符
* sizeof
* 显式类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast
* 标准异常类，引申到C++的异常处理规范

# 4. 函数
* 函数局部静态对象
* initializer_list和省略号类型形参
* 返回花括号列表，直接用于构造函数初始化返回类型
* 默认实参
* 内联函数和constexpr函数

# 5. 类
* 默认构造函数、初始值列表构造函数、委托构造函数
* mutable成员变量，可以被const成员函数修改
* explicit修饰词可以禁止构造函数被用于隐式转换（如果构造函数只有一个参数时, 进行拷贝初始化的时候，在编译的时候就会有一个缺省的转换操作，将该构造函数对应数据类型的数据转换为该类对象）。且只能直接初始化，不能拷贝初始化
* 聚合类、字面值常量类（至少有一个constexpr构造函数）
* 类的静态成员

# 6. 容器、迭代器与泛型
* 序列容器：vector、list等
* emplace类型函数，直接在容器内存空间构造对象，而非构造临时对象再拷贝
* 迭代器：插入迭代器、流迭代器、反向迭代器
* 泛型算法：find、find_if等
* 关联容器：
  * map、set
  * 分为有序（比较）和无序（哈希）；分为可重复与不可重复
  * pair类


# 7. 动态内存与智能指针

## 7.1. 智能指针（自动销毁内存）
* shared_ptr：可复制智能指针
  * make_shared函数为一次性分配所有内存；直接定义为两次内存分配（指针内存和指针指向内存）
  * 可以自定义删除器
  * 智能指针的几个使用规范（见C++ Primer V5 的 417/433页）
* unique_ptr：不可复制智能指针（可以进行原指针即将摧毁的复制如函数返回值）
  * 可以自定义删除器
* weak_ptr：shared_ptr的伴随指针，不改变引用计数，使用前需要核实对象是否已经被释放

## 7.2. 其他特性
* new/delete直接管理内存
* 动态数组及allocator类

# 8. 拷贝控制
## 8.1. 拷贝、赋值与销毁
* 拷贝控制函数
  * 拷贝构造函数（拷贝构造时使用的构造函数）
  * 拷贝赋值运算符（拷贝赋值时使用的重载运算符函数）
  * 析构函数
* 方法
  * 使用=default显示生成合成拷贝控制函数
  * 使用=delete阻止调用拷贝控制函数

## 8.2. 交换
swap函数

## 8.3. 移动
* 右值引用和move函数（该函数会触发移动操作）
* 移动构造函数（移动构造时使用的构造函数）
* 移动赋值运算符（移动赋值时使用的重载运算符函数）
* 移动迭代器

# 9. 面向对象程序设计（OOP）
* 继承后的类型转化，指针、对象的使用关系
* 虚函数
* 纯虚函数（含有纯虚函数的类称作抽象基类，抽象基类无法创建对象），使用=0方法定义
* 继承中的访问权限关系、名称作用域、拷贝控制

