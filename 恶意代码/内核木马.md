<!-- TOC -->

- [1. 内核木马](#1-内核木马)
- [2. 进程隐藏](#2-进程隐藏)
  - [2.1. Ring3层手段](#21-ring3层手段)
  - [2.2. 内核挂钩](#22-内核挂钩)
  - [2.3. EPROCESS.ActiveProcessLinks断链](#23-eprocessactiveprocesslinks断链)
  - [2.4. 抹掉进程句柄](#24-抹掉进程句柄)
    - [2.4.1. 抹掉CSRSS句柄表中的待隐藏进程句柄](#241-抹掉csrss句柄表中的待隐藏进程句柄)
    - [2.4.2. PspCidTable](#242-pspcidtable)
- [3. 文件隐藏](#3-文件隐藏)
  - [3.1. Ring3层手段](#31-ring3层手段)
  - [3.2. SSDT Hook](#32-ssdt-hook)
  - [3.3. 文件过滤驱动](#33-文件过滤驱动)
- [4. 自启动隐藏](#4-自启动隐藏)
  - [4.1. 驱动级系统服务](#41-驱动级系统服务)
  - [4.2. ZwSetSystemInformation](#42-zwsetsysteminformation)
  - [4.3. 其它](#43-其它)
- [5. 通信隐藏](#5-通信隐藏)
  - [5.1. 通信原理](#51-通信原理)
  - [5.2. Hook](#52-hook)
  - [5.3. TDI过滤驱动](#53-tdi过滤驱动)
  - [5.4. NDIS过滤驱动](#54-ndis过滤驱动)
- [6. 驱动模块隐藏](#6-驱动模块隐藏)
- [7. 注册表隐藏](#7-注册表隐藏)
- [8. 服务隐藏](#8-服务隐藏)

<!-- /TOC -->
# 1. 内核木马
内核木马使用无进程、无DLL、无启动项等多种Rootkit技术特征，使得获取更高权限的同时隐蔽性更高。其利用线程注射DLL到系统进程，解除DLL映射并删除自身文件和启动项，关机时恢复。

# 2. 进程隐藏
## 2.1. Ring3层手段
* 混淆字符隐藏，如系统进程名为svchost.exe，木马进程名改为svch0st.exe隐藏
* 注册服务隐藏（进程位于svchost.exe内部），
* dll注入隐藏
  
## 2.2. 内核挂钩
挂钩SSDT，修改进程枚举、查询类函数（如ZwQuerySystemInformation）的返回结果。

## 2.3. EPROCESS.ActiveProcessLinks断链
通过PsGetCurrentProcess()函数找到自身的EPROCESS结然后根据EPROCESS.ActiveProcessLinks双向链表（该双向链表连接了所有进程）遍历所有进程。定位到需要隐藏的进程后，对其进行断链操作。另外，为了防止因指针指向无效内存区域导致系统崩溃，将待摘除的进程的LIST_ENTRY结构中的Flink和Blink指向自身。断链不会影响进程的调度执行，因为Windows是基于线程来实行任务调度的。

## 2.4. 抹掉进程句柄
### 2.4.1. 抹掉CSRSS句柄表中的待隐藏进程句柄
一个进程在创建的时候，系统会为其分配一个句柄表。该句柄表主要是供内核对象调用。实际上，其是一个结构体数组，数组中的每个元素包含了以下三项：指向一个内核对象的指针、访问掩码、与对象句柄的继承相关的一些标志等。对于进程对象来说，其对象指针也放在句柄表中，通过遍历CSRSS句柄表，可以根据需要过滤的特定进程的信息，实现进程的隐藏。

### 2.4.2. PspCidTable
PspCidTable是全局句柄表，存储了所有的进程和线程（无论是否被打开）的指针。该句柄表并未导出，通过PsLookupProcessByProcessId函数定位，过滤掉进程的句柄即可。不过在被隐藏的进程退出时，需要重新恢复原先的进程对象（恢复原先的表的结构），否则，当调用ExDestroyHandle销毁句柄时，遇到不存在的句柄，就会导致蓝屏。

# 3. 文件隐藏
## 3.1. Ring3层手段
* 存放于敏感目录（系统目录）并混淆文件名
* 挂钩应用层上的FindFirstFile,FindNextFile等API来实现该目的

## 3.2. SSDT Hook
Windows中文件的枚举操作，最后都是通过ntdll.dll!NtQueryDirectoryFile进入零环，调用SSDT函数ZwQueryDirectoryFile。

## 3.3. 文件过滤驱动
* 过滤驱动程序：对于文件过滤驱动来说，主要是截获上层文件操作请求，根据需要的功能做相应的处理。
* 文件系统驱动程序（FSD，File System Driver）：它是Windows下标准的核心层驱动程序，主要负责处理用户与磁盘等存储介质之间的存储信息以及维护各种文件系统（如FAT32、NTFS等）的磁盘结构。
* 设备驱动程序：主要是跟相应的硬件打交道，直接依附于相应的硬件设备。磁盘及其他的存储驱动程序主要是实现存储设备的管理、存储等。通过文件过滤驱动实现文件的隐藏，主要是通过设置IRP_MJ_DIRECTORY_ CONTROL分发函数，并在其中设置回调函数，这样发送给文件系统中卷设备的IRP，在从文件系统驱动返回时，将会触发回调函数的执行，在回调函数中将需要过滤的文件从返回的FILE_BOTH_DIR_INFORMATION结构链表中删除，这样就可以实现对指定文件隐藏的功能。

# 4. 自启动隐藏
* 注册表
* 启动目录
* 修改系统启动文件
* 注册为服务
* 修改定时程序
* 感染系统文件技术来实现
## 4.1. 驱动级系统服务
使用SCM把驱动程序注册为系统的一个服务，进而实现自启动。由于涉及到在注册表中插入键值，需要考虑是否会被拦截以及对注册表项和服务项做隐藏。
## 4.2. ZwSetSystemInformation
使用未文档化的API函数ZwSetSystemInformation在不创建注册表键的情况下实现驱动的加载，但是由于驱动程序的分页性，若在驱动运行过程中，通过该种方法加载的内核木马驱动被页换出，则对其的访问就会导致蓝屏。所以针对分页问题进行一定的设计，比如migbot会将全部的操作代码复制到不分页的内存池。
## 4.3. 其它
* BIOS
* 硬盘固件
# 5. 通信隐藏
现在很多已经实现了NDIS小端口驱动层的隐藏，不过主流的木马仍然在TDI层面上通信或者在NDIS中间层上通信
## 5.1. 通信原理
* 用户编写的基于Winsock API的通讯代码
* 网络API DLL给上层的应用程序提供网络的接口
* TDI（Transport DataInterface，传输数据接口）客户是网络API的核心态的驱动程序，它可根据相应的网络标准格式化相应的数据包，传送给协议驱动
* TDI传送器即NDIS（Network Driver Interface Specification，网络驱动接口规范）协议驱动程序，它接受上层传送过来的数据包，接着根据不同的需求，按照不同的协议（TCP、IPX等）给数据包添加相应的协议头，以便提供给下层做进一步的处理；
* NDIS库则在为其上下层提供接口，同时也隐藏了设备的细节，使协议驱动程序跟网卡驱动程序通信时不用考虑设备相关性，直接通过这些接口透明地进行通信
## 5.2. Hook
Netstat、Fport等获取端口列表的工具的调用链为`iphlpapi.dll!AllocateAndGetTcpTableFromStack -> ntdll!NtDeviceIoControlFile -> nt!ZwDeviceIoControlFile`，只要Hook相关函数，对返回的端口信息进行过滤即可实现端口隐藏。但是该方法对通过TDI过滤驱动来获取网络连接的方式无效。
## 5.3. TDI过滤驱动
应用层的网络应用程序要发送或接收数据，都得通过下层的驱动程序来格式化这些数据。那么只要在上层的IRP到达之后，根据自己的需求设定过滤规则，对特定的信息进行过滤，会使用户层的一些检测工具或使用同种机制实施过滤的防火墙无法查看到自己已经处理过的通信信息。不过该过滤驱动位于TcpIp.sys之上，属于UpperDriver，若一些检测工具或防火墙是通过TcpIp.sys来获取通信的信息的，那么该种方法就无法对特定的数据包实施过滤，也就难以逃避检测。
## 5.4. NDIS过滤驱动
NDIS是Microsoft和3COM公司联合制定的网络驱动接口规范，其包括NDISProtocol Driver（NDIS协议驱动）、NDIS Intermediate Driver（NDIS中间层驱动）、NDIS MiniPortDriver（NDIS微端口驱动，有的文献中也称之为NDIS小端口驱动）。在这三个层次的驱动中，在后两个上可以获取系统的网络通信的相关信息，如源地址、目的地址等，这样就可以在这两个层次较为方便的获得关于通信隐藏的依据，进而将这些信息直接发往自己的木马功能模块或者调用原先的流程继续传递。直接发往木马模块的通信信息由于没有通过系统的常规流程，因而，基于这些流程中间一些层次上的检测工具或防火墙将无法截获到这些信息。
# 6. 驱动模块隐藏
所有的驱动模块会通过MODULE_ENTRY双向链表连接，找到对应的驱动模块进行断链即可。同样的，断链时需要将模块的LIST_ENTRY结构中的Flink和Blink指向自身以防蓝屏。
# 7. 注册表隐藏
若要实现对注册表中一些键值的隐藏，只需打破这种正常的调用机制，在其中某个易于操作的环节将键值过滤掉即可。对于内核层来说，通过挂钩或修改SSDT表、ntoskrnl.exe等中的相关函数等，就可以完成该功能。
# 8. 服务隐藏
