<!-- TOC -->

- [1. 调用约定](#1-调用约定)
  - [1.1. prolog和epilog代码](#11-prolog和epilog代码)
    - [1.1.1. 头部代码：prolog代码](#111-头部代码prolog代码)
    - [1.1.2. 编译器的栈帧指针省略选项](#112-编译器的栈帧指针省略选项)
    - [1.1.3. 系统函数](#113-系统函数)
    - [1.1.4. 尾部代码：epilog代码](#114-尾部代码epilog代码)
    - [1.1.5. ENTER和LEAVE](#115-enter和leave)
- [2. Windows操作系统](#2-windows操作系统)
- [3. 其它](#3-其它)
- [4. 光通信](#4-光通信)
  - [4.1. 传输模式](#41-传输模式)
  - [4.2. 光纤](#42-光纤)
- [5. Zw系列函数和Nt系列函数的区别](#5-zw系列函数和nt系列函数的区别)
  - [5.1. previous mode](#51-previous-mode)
  - [5.2. 用户模式（ntdll.dll中调用）](#52-用户模式ntdlldll中调用)
  - [5.3. 内核模式（ntoskrnl.exe中调用）](#53-内核模式ntoskrnlexe中调用)
  - [5.4. ntdll.dll和ntoskrnl.exe中ZW系列函数的区别](#54-ntdlldll和ntoskrnlexe中zw系列函数的区别)

<!-- /TOC -->
# 1. 调用约定
* cdecl，参数从右往左入栈，调用者清理栈，返回值位于EAX，C语言的标准调用约定
* stdcall，参数从右往左入栈，被调用者清理栈，返回值位于EAX，这个是Windows API的标准调用约定
* fastcall，先用EDX、ECX，再用栈传递参数，被调用者清理栈，返回值位于EAX
* C++调用约定 使用this指针
* VC提供了this call调用， 将this传递给ecx
* gc++中被当做静态变量，存放在栈顶

## 1.1. prolog和epilog代码
### 1.1.1. 头部代码：prolog代码
一个函数的prolog代码主要是为这个函数的执行做一些准备工作，例如设置堆栈帧、设置局部变量所使用的堆栈空间以及保存相关的寄存器等。标准的prolog代码开头一般为以下三条指令：
```x86asm
PUSH   EBP          // 保存上一个函数的栈帧
MOV    EBP, ESP     // 设置堆栈帧
SUB    ESP, XXX     // 为局部变量开辟空间，如果局部变量较少，编译器往往会使用类似于PUSH ECX这样的指令来开辟空间
//后面一般还有几条PUSH指令用于保存函数使用的寄存器（一般是EBX、ESI和EDI）
```
这三条指令为使用EBP寄存器来访问函数的参数（正偏移）和局部变量（负偏移）做好了准备。由于ESP会在函数执行期间变化，所以使用EBP寄存器（一般在整个函数中都不会变化）来作为栈帧指针。
### 1.1.2. 编译器的栈帧指针省略选项
大多数C/C++编译器都有栈帧指针省略（Frame-Pointer Omission）选项（在Microsoft C/C++编译器中为/Oy），它导致函数不使用堆栈帧，而是使用ESP来访问参数和局部变量，从而可以空闲出一个寄存器（EBP）用于其它目的，并稍微提高运行速度。但是在某些情况下必须使用堆栈帧，比如在使用了SEH的函数中。
### 1.1.3. 系统函数
在一些系统DLL如NTDLL.DLL中，许多函数的prolog代码的第一条指令并不是上面所说的`PUSH EBP`，而是一条垃圾指令`MOV EDI, EDI`（占两个字节），并且函数前面有五条NOP指令（占五个字节）。它们是微软对系统打热补丁时供Hook该API时用的，修补程序在五条NOP指令处写入一个远跳转指令（占五个字节），以跳转到被修补过的代码处。而`MOV EDI, EDI`处用一个近跳转指令（占两个字节）覆盖，它跳转到五个NOP指令所在的位置。使用`MOV EDI, EDI`而不是直接使用两个NOP指令是出于性能考虑。
### 1.1.4. 尾部代码：epilog代码
它主要做一些清理工作。标准代码如下：
```
// 前面可能还有几条POP指令用于恢复在prolog代码中保存的寄存器（如果存在的话）
MOV     ESP, EBP
POP     EBP
RET     XXX
```
最后的RET指令中的XXX指定了弹出的字节数，一般用于将参数弹出堆栈，因此从这个值就可以知道函数的参数个数（每个参数均为4字节）。
### 1.1.5. ENTER和LEAVE
为了简化操作，Intel引入了ENTER和LEAVE指令。其中ENTER相当于前面所说的prolog代码的前两条指令，而LEAVE相当于上面的epilog代码的前两条指令。但是由于实现上ENTER指令比前面所说的两条指令执行速度慢，因此编译器都不使用这条指令。这样，你实际看到的情况就 是：prolog代码就是前面所说的那样，但epilog代码使用了LEAVE指令。
# 2. Windows操作系统
* `\\?\`前缀告诉操作系统禁用字符串解析
* `\\ServerName\share`和`\\?\serverName\share`开头的文件为共享文件
* `\\.\`开头的文件为Win32设备名字空间，可以直接访问物理设备（Windows2003之后只能从Ring0访问）
* 备用数据流（ADS）允许附加数据添加到一个已存在的NTFS文件中，这个数据只有在访问流时才会可见，命名为normalFile.txt:Stream:$DATA
* 进程中每个线程共享内存空间，但是拥有自己的寄存器、CPU、栈
* 组件对象模型（COM）是一个接口标准，使用COM的线程必须在调用任何其它COM函数之前，至少一次调用OleInitialize或CoInitializeEx函数，COM对象通过全局唯一标识符（GUID=CLSID+IID）访问
* 原生API，参数粒度更细，提供信息更多，可以绕过普通API，NtContinue被用来从一个异常处理返回主线程，返回的位置可以被指定
* PE头的子系统指明了一个程序是不是原生应用程序
* 设置DR7寄存器中的通用探测标志位，任何通过mov指令访问调试寄存器的操作都会触发中断（别的指令不会触发）
* 调试器可能两次处理同一异常，调试器第一次捕获异常后将其传递给程序，程序无法处理时，会再次转给调试器，如果调试器不处理，程序就会崩溃
* 调试器会对INT3异常进行特殊处理，操作系统则不会
* 可以通过rundll和修改PE头的方式来运行dll文件
# 3. 其它
* 编译代码时，debug版本会遵循ebp规范，堆栈结构清晰，release版本会做大量代码优化，堆栈结构可能会出现混乱。但是在有try-catch机制的函数中，release版本不会做任何优化，以防堆栈结构出现错误
* VC6编译器，编译的所有异常处理函数名称永远是__except_handler3
* GUI（图形用户接口，使用微软已经画好的窗口）、GDI（图形设备接口，自己画窗口）
* GUI编程、GDI编程：HDC、窗口、画刷等等对象
* source insight工具，查看源代码

# 4. 光通信
## 4.1. 传输模式
|项目|单模|多模|
|:-:|:-:|:-:|
|传输距离|长|短（极端情况下300m以内）|
|传输波长|1260-1640nm|850-1300nm|
|带宽限制|几乎不存在带宽限制|存在带宽限制|
|价格|收发设备昂贵，光纤便宜，总体昂贵|收发设备便宜，光纤稍贵，总体便宜|
|肉眼可见光|肉眼不可见光|肉眼可见红光|
## 4.2. 光纤
|颜色|传输模式|流量大小|标准|
|:-:|:-:|:-:|:-:|
|黄色|单模||OS1、OS2|
|橙色|多模|千兆|OM1、OM2|
|蓝色|多模|万兆|OM3|
|紫色|多模|万兆|OM4|
|绿色|多模|万兆|OM5|

# 5. Zw系列函数和Nt系列函数的区别
这里以NtOpenProcess和ZwOpenProcess为例，结合Windbg的lkd调试来说明。
## 5.1. previous mode
如果是从用户模式调用Native API则previous mode是用户态，如果是从内核模式调用Native API则previous mode是内核态。previous为用户态时Native API将对传递的参数进行严格的检查，而为内核态时则不会。
## 5.2. 用户模式（ntdll.dll中调用）
```x86asm
lkd> u ntdll!zwopenprocess l4
ntdll!ZwOpenProcess:
7c92d5fe b87a000000      mov     eax,7Ah           //函数调用号
7c92d603 ba0003fe7f      mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)     //函数地址
7c92d608 ff12            call    dword ptr [edx]
7c92d60a c21000          ret     10h

lkd> u ntdll!ntopenprocess l4
ntdll!ZwOpenProcess:
7c92d5fe b87a000000      mov     eax,7Ah
7c92d603 ba0003fe7f      mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)
7c92d608 ff12            call    dword ptr [edx]
7c92d60a c21000          ret     10h
```
二者没有任何区别，都是通过SSDT服务表，通过系统服务调度程序KiSystemService调用ntoskrnl.exe中的中断处理程序Nt系列函数。

在用户模式（ntdll.lib）下，二者没有任何区别，均为通过设置系统服务表中的索引和在堆栈中设置参数，经由SYSENTER指令进入内核态（而不是象w2k中通过int 0x2e中断），并最终由KiSystemService跳转到KiServiceTable对应的系统服务例程中。由于是从用户模式进入内核模式，因此代码会严格检查用户空间传入的参数。
## 5.3. 内核模式（ntoskrnl.exe中调用）
```x86asm
lkd> u nt!zwopenprocess l6
nt!ZwOpenProcess:
804e4c0a b87a000000      mov     eax,7Ah
804e4c0f 8d542404        lea     edx,[esp+4]
804e4c13 9c              pushfd
804e4c14 6a08            push    8
804e4c16 e8b69bffff      call    nt!KiSystemService (804de7d1)
804e4c1b c21000          ret     10h

lkd> u nt!ntopenprocess l20
nt!NtOpenProcess:
80582702 68c4000000      push    0C4h
80582707 68e8524f80      push    offset nt!ObWatchHandles+0x25c (804f52e8)
8058270c e87217f6ff      call    nt!_SEH_prolog (804e3e83)
80582711 33f6            xor     esi,esi
80582713 8975d4          mov     dword ptr [ebp-2Ch],esi
80582716 33c0            xor     eax,eax
80582718 8d7dd8          lea     edi,[ebp-28h]
8058271b ab              stos    dword ptr es:[edi]
8058271c 64a124010000    mov     eax,dword ptr fs:[00000124h]
80582722 8a8040010000    mov     al,byte ptr [eax+140h]
80582728 8845cc          mov     byte ptr [ebp-34h],al
8058272b 84c0            test    al,al
8058272d 0f840e7b0100    je      nt!NtOpenProcess+0xc0 (8059a241)
80582733 8975fc          mov     dword ptr [ebp-4],esi
80582736 a1d48e5680      mov     eax,dword ptr [nt!MmUserProbeAddress (80568ed4)]
8058273b 8b4d08          mov     ecx,dword ptr [ebp+8]
8058273e 3bc8            cmp     ecx,eax
80582740 0f8315170800    jae     nt!NtOpenProcess+0x40 (80603e5b)
80582746 8b01            mov     eax,dword ptr [ecx]
80582748 8901            mov     dword ptr [ecx],eax
8058274a 8b5d10          mov     ebx,dword ptr [ebp+10h]
8058274d f6c303          test    bl,3
80582750 0f850c170800    jne     nt!NtOpenProcess+0x4e (80603e62)
80582756 a1d48e5680      mov     eax,dword ptr [nt!MmUserProbeAddress (80568ed4)]
8058275b 3bd8            cmp     ebx,eax
8058275d 0f8309170800    jae     nt!NtOpenProcess+0x5c (80603e6c)
80582763 397308          cmp     dword ptr [ebx+8],esi
80582766 0f9545e6        setne   byte ptr [ebp-1Ah]
8058276a 8b4b0c          mov     ecx,dword ptr [ebx+0Ch]
8058276d 894dc8          mov     dword ptr [ebp-38h],ecx
80582770 8b4d14          mov     ecx,dword ptr [ebp+14h]
80582773 3bce            cmp     ecx,esi
```
Nt系列函数是直接调用对应功能代码，而Zw系列函数是在ring 0下通过SSDT服务表，KiSystemService调用ntoskrnl.exe中的中断处理程序Nt系列函数。

在内核模式（nooskrnl.lib）下，调用Nt系列函数时不会改变previous mode的状态，调用Zw系列函数时会将previous mode改为内核态。因此在进行Kernel Mode Driver开发时可以使用Zw系列函数来避免额外的参数列表检查，提高效率。
## 5.4. ntdll.dll和ntoskrnl.exe中ZW系列函数的区别
* ntdll.dll：传入服务号到eax——>调用SharedUserData!SystemCallStub (7ffe0300)函数->KiSystemService---->Nt系列函数(ntoskrnl)
* ntoskrnl.exe：传入服务号eax——>KiSystemService--->Nt系列函数(ntoskrnl)
